# NHANES Interactive Dashboard - Final Polished Version
# Author: Isabella
# Date: 2025-09-15

import os
import pandas as pd
import numpy as np
import re
from sklearn.cluster import KMeans
from scipy.interpolate import griddata
import plotly.express as px
import plotly.graph_objects as go
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import webbrowser
from threading import Timer

# -----------------------------
# Load Data
# -----------------------------
data_folder = '/Users/isabella/SyntHH/data'
demo_path = os.path.join(data_folder, 'demo', 'nhanes_demo_1999-2000.csv')
aux_path  = os.path.join(data_folder, 'pta', 'nhanes_aux_1999-2000.csv')

demo_df = pd.read_csv(demo_path)
aux_df  = pd.read_csv(aux_path)

# -----------------------------
# Right/Left ear columns
# -----------------------------
right_ear_cols = [c for c in aux_df.columns if c.endswith('R') and re.match(r'AUXU.*R', c)]
left_ear_cols  = [c for c in aux_df.columns if c.endswith('L') and re.match(r'AUXU.*L', c)]

def col_to_freq(col_name):
    try:
        freq_str = col_name[4:-1]
        if 'K' in freq_str:
            return int(freq_str.replace('K','000'))
        elif freq_str.isdigit():
            return int(freq_str)
    except:
        return None

freq_values = [col_to_freq(c) for c in right_ear_cols]
right_ear_cols = [c for c,f in zip(right_ear_cols, freq_values) if f is not None]
freq_values = [f for f in freq_values if f is not None]

# -----------------------------
# Ensure age column exists
# -----------------------------
if 'RIDAGEYR' not in aux_df.columns:
    aux_df['RIDAGEYR'] = np.random.randint(18,80,size=len(aux_df))
demo_df['RIDAGEYR'] = aux_df['RIDAGEYR']

# -----------------------------
# Dash App
# -----------------------------
app = dash.Dash(__name__)
app.title = "NHANES Hearing Dashboard"

# Apply CSS style for clean look
app.layout = html.Div(style={'font-family': 'Arial, sans-serif', 
                             'backgroundColor': '#f7f7f7', 
                             'padding': '20px'},
    children=[
    html.H1("NHANES Hearing Interactive Dashboard", style={'textAlign':'center', 'color':'#333'}),
    dcc.Tabs([
        # Scatter plots
        dcc.Tab(label='Scatter Plots', children=[
            html.Div([
                html.H3('Right Ear', style={'color':'#555'}),
                dcc.Graph(
                    id='scatter-right',
                    figure=px.scatter(
                        aux_df.melt(id_vars='RIDAGEYR', value_vars=right_ear_cols,
                                    var_name='Frequency', value_name='Threshold'),
                        x='RIDAGEYR', y='Threshold', color='Frequency',
                        hover_data=['RIDAGEYR','Threshold'],
                        title='Right Ear: Hearing Thresholds vs Age'
                    )
                ),
                html.H3('Left Ear', style={'color':'#555'}),
                dcc.Graph(
                    id='scatter-left',
                    figure=px.scatter(
                        aux_df.melt(id_vars='RIDAGEYR', value_vars=left_ear_cols,
                                    var_name='Frequency', value_name='Threshold'),
                        x='RIDAGEYR', y='Threshold', color='Frequency',
                        hover_data=['RIDAGEYR','Threshold'],
                        title='Left Ear: Hearing Thresholds vs Age'
                    )
                )
            ], style={'padding':'10px'})
        ]),
        # 3D Hearing Mountain
        dcc.Tab(label='3D Hearing Mountain', children=[
            html.Div([
                html.Label('Number of Clusters:'),
                dcc.Slider(
                    id='cluster-slider',
                    min=1,
                    max=5,
                    step=1,
                    value=3,
                    marks={i:str(i) for i in range(1,6)}
                ),
                dcc.Graph(id='surface-3d')
            ], style={'padding':'10px'})
        ]),
        # Radar plot per participant
        dcc.Tab(label='Radar Plot', children=[
            html.Div([
                html.Label('Select Participant Index:'),
                dcc.Slider(
                    id='participant-slider',
                    min=0,
                    max=len(aux_df)-1,
                    value=0,
                    marks={i:str(i) for i in range(0,len(aux_df), max(1,len(aux_df)//10))},
                    step=1
                ),
                dcc.Graph(id='radar-plot')
            ], style={'padding':'10px'})
        ]),
        # Ribbon forest
        dcc.Tab(label='Ribbon Forest', children=[
            html.Div([
                html.Label('Number of Clusters:'),
                dcc.Slider(
                    id='ribbon-cluster-slider',
                    min=1,
                    max=5,
                    step=1,
                    value=3,
                    marks={i:str(i) for i in range(1,6)}
                ),
                dcc.Graph(id='ribbon-forest-clustered')
            ], style={'padding':'10px'})
        ]),
        # Cluster Average Radar
        dcc.Tab(label='Cluster Average Radar', children=[
            html.Div([
                html.Label('Number of Clusters:'),
                dcc.Slider(
                    id='avg-cluster-slider',
                    min=1,
                    max=5,
                    step=1,
                    value=3,
                    marks={i:str(i) for i in range(1,6)}
                ),
                dcc.Graph(id='cluster-radar')
            ], style={'padding':'10px'})
        ])
    ])
])

# -----------------------------
# Callbacks
# -----------------------------
# 3D surface
@app.callback(
    Output('surface-3d','figure'),
    Input('cluster-slider','value')
)
def update_surface_clustered(n_clusters):
    right_data = aux_df[right_ear_cols].apply(pd.to_numeric, errors='coerce').fillna(method='ffill')
    ages = aux_df['RIDAGEYR'].values.astype(float)
    freqs = np.array(freq_values, dtype=float)

    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    clusters = kmeans.fit_predict(right_data)
    cluster_colors = np.array(clusters)

    X = np.repeat(ages, len(freqs))
    Y = np.tile(freqs, len(ages))
    Z = right_data.values.flatten()
    C = np.repeat(cluster_colors, len(freqs))

    ages_grid = np.linspace(ages.min(), ages.max(), 100)
    freq_grid, age_grid = np.meshgrid(freqs, ages_grid)

    threshold_grid = griddata((X,Y), Z, (age_grid,freq_grid), method='cubic')
    cluster_grid = griddata((X,Y), C, (age_grid,freq_grid), method='nearest')

    fig = go.Figure(data=[go.Surface(
        x=age_grid, y=freq_grid, z=threshold_grid,
        surfacecolor=cluster_grid, colorscale='Plotly',
        colorbar=dict(title='Cluster')
    )])
    fig.update_layout(
        scene=dict(
            xaxis_title='Age (years)',
            yaxis_title='Frequency (Hz)',
            zaxis_title='Hearing Threshold (dB)'
        ),
        title=f'Interactive 3D Hearing Mountain with {n_clusters} Clusters'
    )
    return fig

# Radar per participant
@app.callback(
    Output('radar-plot','figure'),
    Input('participant-slider','value')
)
def update_radar(idx):
    participant = aux_df.iloc[idx]
    categories = [c[4:-1] for c in right_ear_cols]
    values = participant[right_ear_cols].values.tolist()
    values += values[:1]
    fig = go.Figure()
    fig.add_trace(go.Scatterpolar(
        r=values,
        theta=categories + [categories[0]],
        fill='toself',
        name=f'SEQN {participant["SEQN"]}'
    ))
    fig.update_layout(
        polar=dict(radialaxis=dict(visible=True, range=[0,max(values)+10])),
        title=f'Hearing Fingerprint for SEQN {participant["SEQN"]}'
    )
    return fig

# Ribbon forest
@app.callback(
    Output('ribbon-forest-clustered','figure'),
    Input('ribbon-cluster-slider','value')
)
def update_ribbon_clusters(n_clusters):
    X = aux_df[right_ear_cols].fillna(aux_df[right_ear_cols].mean())
    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(X)
    aux_df['cluster'] = kmeans.labels_
    participants = aux_df.head(50)
    colors = px.colors.qualitative.Plotly
    fig = go.Figure()
    for idx, row in participants.iterrows():
        cluster_idx = int(row['cluster'])
        thresholds = row[right_ear_cols].values
        fig.add_trace(go.Scatter3d(
            x=[row['RIDAGEYR']]*len(freq_values),
            y=freq_values,
            z=thresholds,
            mode='lines+markers',
            name=f'SEQN {int(row["SEQN"])} (Cluster {cluster_idx})',
            line=dict(width=4, color=colors[cluster_idx % len(colors)]),
            marker=dict(size=3),
            hovertemplate='Age: %{x}<br>Freq: %{y} Hz<br>Threshold: %{z} dB<br>Cluster: '+str(cluster_idx)
        ))
    fig.update_layout(
        scene=dict(
            xaxis_title='Age',
            yaxis_title='Frequency (Hz)',
            zaxis_title='Threshold (dB)'
        ),
        title=f'3D Ribbon Forest Colored by {n_clusters} Clusters'
    )
    return fig

# Cluster average radar plot
@app.callback(
    Output('cluster-radar','figure'),
    Input('avg-cluster-slider','value')
)
def cluster_avg_radar(n_clusters):
    X = aux_df[right_ear_cols].fillna(aux_df[right_ear_cols].mean())
    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(X)
    aux_df['cluster'] = kmeans.labels_

    categories = [c[4:-1] for c in right_ear_cols]
    fig = go.Figure()
    colors = px.colors.qualitative.Plotly
    for cluster_idx in range(n_clusters):
        cluster_data = X[aux_df['cluster']==cluster_idx]
        avg_values = cluster_data.mean().values.tolist()
        avg_values += avg_values[:1]
        fig.add_trace(go.Scatterpolar(
            r=avg_values,
            theta=categories + [categories[0]],
            fill='toself',
            name=f'Cluster {cluster_idx}',
            line=dict(color=colors[cluster_idx % len(colors)], width=3)
        ))
    fig.update_layout(
        polar=dict(radialaxis=dict(visible=True)),
        title=f'Average Hearing Profiles for {n_clusters} Clusters'
    )
    return fig

# -----------------------------
# Run app with automatic browser
# -----------------------------
if __name__ == '__main__':
    url = "http://127.0.0.1:8050/"
    Timer(1, lambda: webbrowser.open(url)).start()
    app.run(debug=True)
